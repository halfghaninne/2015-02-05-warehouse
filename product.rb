require 'pry'
require 'sqlite3'



DATABASE = SQLite3::Database.new("warehouse_mgr.db")

DATABASE.results_as_hash = true

# Class: Product
#
# Creates new product objects/records for products table in warehouse_mgr database
# 
# Attributes:
# + @id              - Integer: Primary key ##user shouldn't overwrite##
# + @serial_number   - Integer 
# + @description     - String:
# + @quantity        - Integer:
# + @cost            - Integer: ##CONSIDER CHANGING TO FLOAT/OTHER VALUE##
# + @location_id     - Integer: Foreign key ##RESTRICT VALUES##
# + @category_id     - Integer: Foreign key ##RESTRICT VALUES##
#
# Public Methods:
# ???
#
# Private Methods:
# + insert

class Product
  
  attr_reader :id
  
  attr_accessor :location_id, :cost, :quantity, :serial_number, :description, 
                :category_id
  
  # Public or Private?: .initialize
  # Gathers arguments (field values) in an options Hash; automatically inserts them into the products table via private method .insert
  #
  # Parameters:
  # + options = {serial_number: Integer, name: String, description: String,     quantity: Integer, cost: Integer, location_id: Integer, category_id: Integer} ##Should we include id? User should never input##
  #
  # Returns: 
  # ???
  # 
  # State Changed:
  # ???
  
  def initialize(options)
    @serial_number = options["serial_number"]
    @description = options["description"]
    @quantity = options["quantity"]
    @cost = options["cost"]
    @location_id = options["location_id"]
    @category_id = options["category_id"]
  end

  ## MOVE TO MODULE ##
  def save
    attributes = []
    
    instance_variables.each do |i|
      attributes << i.to_s.delete("@")
    end
    
    query_components_array = []
    
    attributes.each do |a|
      value = self.send(a)
      
      if value.is_a?(Integer)
        query_components_array << "#{a} = #{value}"
      else
        query_components_array << "#{a} = '#{value}'"
      end
    end
       
    query_string = query_components_array.join(", ")
    
    DATABASE.execute("UPDATE products SET #{query_string} WHERE id = #{id}")
  end
  
  # Public: .insert
  # Syntax to enter the Ruby object's arguments as a records' field values via sqlite3
  #
  # Parameters:
  #
  # Returns: 
  # Integer - @id, "id" field value, generated by table upon creation and pulled from the record
  # 
  # State Changed:
  # ???
  
  def insert
    DATABASE.execute("INSERT INTO products (serial_number, description, 
                      quantity, cost, location_id, category_id) 
                      VALUES (#{@serial_number}, '#{@description}', 
                      #{@quantity}, #{@cost}, #{@location_id}, #{@category_id})")
    # At present, 0's are entered in for integer values that are not entered, need to change this to our default settings. Blank field left for empty text values.
    @id = DATABASE.last_insert_row_id
  end
  
  def self.delete(record_id)
    DATABASE.execute("DELETE FROM products WHERE id = #{record_id}")
  end
  
  
  def self.fetch_by(options) #ex: Product.fetch_by("location_id" => 2)
    v = []
    k = []
    options.each_key {|key| k << "#{key}"}
    options.each_value {|value| v << "#{value}"}
    
    field = k[0].to_s
    search_value = v[0].to_i
    
    search_query = "SELECT * FROM products WHERE #{field} = #{search_value}"
        
    results = DATABASE.execute("#{search_query}")
    
    results_as_objects = []

    results.each do |r|
      results_as_objects << self.new(r)
    end

    results_as_objects
        
  end

                  
  def self.find(record_id)
    results = DATABASE.execute("SELECT * FROM products WHERE id = #{record_id}")
    record_details = results[0]
    self.new(record_details)
  end

  def self.all
    DATABASE.execute("SELECT * FROM products")
  end
  
end

binding.pry